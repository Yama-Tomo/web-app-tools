import { execSync } from 'node:child_process'
import * as fs from 'node:fs'
import * as os from 'node:os'
import * as path from 'node:path'

import * as ts from 'typescript'

const REPO_URL = 'https://github.com/chakra-ui/chakra-ui.git'
const VERSION = '3.33.0'
const TAG_NAME = `@chakra-ui/panda-preset@${VERSION}`
const TARGET_FUNCTIONS: Record<string, string> = {
  defineRecipe: 'recipes',
  defineSlotRecipe: 'slotRecipes',
  defineTokens: 'tokens',
  defineSemanticTokens: 'semanticTokens',
  defineGlobalStyles: 'globalCss',
  defineAnimationStyles: 'animationStyles',
  defineTextStyles: 'textStyles',
  defineLayerStyles: 'layerStyles',
  defineUtilities: 'utilities',
}
const TARGET_VARIABLES: Record<string, string> = {
  breakpoints: 'breakpoints',
  keyframes: 'keyframes',
  createFocusRing: 'utilities',
}

function getTsFiles(dir: string): string[] {
  const files: string[] = []
  const entries = fs.readdirSync(dir, { withFileTypes: true })
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      files.push(...getTsFiles(fullPath))
    } else if (entry.isFile() && fullPath.endsWith('.ts')) {
      files.push(fullPath)
    }
  }
  return files
}

function asConst(node: ts.Node) {
  const isLiteral = ts.isObjectLiteralExpression(node) || ts.isArrayLiteralExpression(node)
  return isLiteral ? ' as const' : ''
}

async function runExtraction(tempDir: string, outDir: string, scriptName: string) {
  const sourceThemeDir = path.join(tempDir, 'packages/panda-preset/src')

  console.log(`‚úÖ Target version: ${VERSION} (Tag: ${TAG_NAME})`)

  console.log(`\nüì¶ Downloading source code for ${TAG_NAME} from GitHub...`)
  try {
    execSync(`git clone --depth 1 --branch ${TAG_NAME} ${REPO_URL} ${tempDir}`, {
      stdio: 'ignore',
    })
    console.log('‚úÖ Download complete')
  } catch {
    throw new Error(`Git clone failed. The tag ${TAG_NAME} might not exist.`)
  }

  const extractedCodes: Record<string, { name: string; code: string }[]> = {}

  const sourceFilePaths = getTsFiles(sourceThemeDir)
  for (const sourceFilePath of sourceFilePaths) {
    const fileContent = fs.readFileSync(sourceFilePath, 'utf-8')

    const sourceFile = ts.createSourceFile(
      sourceFilePath,
      fileContent,
      ts.ScriptTarget.Latest,
      true,
    )

    const visit = (node: ts.Node) => {
      if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name)) {
        const initializer = node.initializer
        if (!initializer) return

        const varName = node.name.text
        const category = TARGET_VARIABLES[varName]
        if (category) {
          extractedCodes[category] ||= []
          extractedCodes[category].push({
            name: varName,
            code: `export const ${varName} = ${initializer.getText(sourceFile)}${asConst(initializer)}\n\n`,
          })
        }

        if (ts.isCallExpression(initializer)) {
          const funcName = initializer.expression.getText(sourceFile)
          const [, category] =
            Object.entries(TARGET_FUNCTIONS).find(([func]) => funcName.includes(func)) || []
          if (!category) return

          const argNode = initializer.arguments[0]
          if (!argNode) return

          extractedCodes[category] ||= []
          extractedCodes[category].push({
            name: varName,
            code: `export const ${varName} = ${argNode.getText(sourceFile)}${asConst(argNode)}\n\n`,
          })
        }
      }
      ts.forEachChild(node, visit)
    }

    visit(sourceFile)
  }

  const outFiles = Object.entries(extractedCodes).map(([category, codes]) => {
    const sortedCodes = [...codes].sort((a, b) => a.name.localeCompare(b.name))

    let content = `
    /**
     * Code generated by ${scriptName}. DO NOT EDIT.
     * Extracted from @chakra-ui/panda-preset version ${VERSION}
     */
    // biome-ignore-all lint: auto-generated file\n\n`

    if (category === 'utilities') {
      content += `// @ts-nocheck\n\n`
    }

    content += sortedCodes.map(({ code }) => code).join('')

    if (category === 'recipes') {
      content += `export const ${category} = {
        ${sortedCodes.map(({ name }) => `${name.replace('Recipe', '')}: ${name}`).join(',')}
      };`
    } else if (category === 'slotRecipes') {
      content += `export const ${category} = {
        ${sortedCodes.map(({ name }) => `${name.replace('SlotRecipe', '')}: ${name}`).join(',')}
      };`
    }

    if (!fs.existsSync(outDir)) {
      fs.mkdirSync(outDir, { recursive: true })
    }

    const outFile = path.join(outDir, `${category}.ts`)
    fs.writeFileSync(outFile, content, 'utf-8')

    return outFile
  })

  try {
    execSync(`pnpm -C ../../ lint:fix ${outFiles.join(' ')}`, { stdio: 'ignore' })
  } catch {
    console.warn('‚ö†Ô∏è  Biome formatting skipped (biome command failed or not found).')
  }
}

async function main() {
  const outDir = path.resolve(process.cwd(), './vendor/chakraPreset/')
  const scriptName = path.basename(__filename)

  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'chakra-recipes-'))

  try {
    await runExtraction(tempDir, outDir, scriptName)
    console.log(`üéâ Done! Installed to ${outDir}`)
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    console.error(`\n‚ùå An error occurred:\n`, message)
    process.exit(1)
  } finally {
    if (fs.existsSync(tempDir)) {
      console.log('\nüßπ Cleaning up temporary directory...')
      fs.rmSync(tempDir, { recursive: true, force: true })
    }
  }
}

main()
